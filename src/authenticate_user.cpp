/**
 * @file authenticate_user.cpp
 * @brief Implementation of authenticate_user module
 * @author Star Poon <star.poon@connect.polyu.hk>
 * @version 1.0
 * @copyright 2015
 *
 * @section LICENSE
 * Copyright (C) 2015 Star Poon
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <string>
#include <sstream>
#include <map>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/pem.h>
#include <openssl/bio.h>
#include <openssl/rsa.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>

extern "C" {
	#include "libscrypt.h"
	#include "b64.h"
}

//use public key to decrypt the data in list.txt
//Generated by:
//openssl rsa -in key.pem -pubout
//This is 4096-bits public key
unsigned char publicKey[]="-----BEGIN PUBLIC KEY-----\n"\
"MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEApLy+6mhH5DDO500UgyNQ\n"\
"+vlUB2q81PM9hzdZWi8zWC00PiI01/D4A6wvsZhkDi7O6twvfKJw8uuKv31G6Jq5\n"\
"Mb16SwK/ZTMkhZo7K4kLInm6KBffghV0YiO13YjvApd5WcfrV01bM0iulAaKjbk2\n"\
"X2QqU3SYndCFzymMvYKX8DweQRDIYn9c80rnCOVE7NcF6KfQDwZvpSYYafAuKCHo\n"\
"HPoZfkm9fCBlzmNSXTfyf6J4KyBl5mfvb6StRq5z+nl0hISgDrOCmbN9HJO6F9D5\n"\
"5QYrIb76xIhhdFiq+64maQwFEQHQb9BbrhmipyAGiw80Qu+RfpB7H+pMqAiIonWP\n"\
"4GYSPXLWxUXzp6jCWGVol6wfikj1xXA3xWG6kzbORi5PPW5Fm+SUeaHfGIvaOEGv\n"\
"sGT2qPHMC+oYjzvJHUDBEt5s/aUqYjIblqGKs5CO/TUURgGjUIvPGFS8+IZYKhqR\n"\
"p5GgY0KQUisqXSJBXIgPjUeSPArfbZD9I6WdLDejDsHsM2QBoFkCkYP7Pc1YkQ5Y\n"\
"LLvwmENYSZpeRUHdOD52dGvbnuzY2R2KclD2IFDRjBnvWtzVMbv7k6Pdgr5dKJ+l\n"\
"X7kyy1u1BK+hnqAoZOyfPUrR1w3y9pHfCLXsiZuUn6Xsn7SHz1yLe4Vq4E+r7E8S\n"\
"xzKBHUz3LWEMp6j5xlC7o8cCAwEAAQ==\n"\
"-----END PUBLIC KEY-----\n";


#define MAX_USERNAME 150
#define MAX_PASSWORD 150

using namespace std;

//Authenticate module for Password-Based Authentication System
class AuthenticateUser {
	public:
		//verify the user is in the list.txt generated by create_user module
		bool VerifyUser(const string username, const string password);

		//load the list.txt, decrypt and verify it's origin+data integrity
		void Load(const string filename);

		//print userlist, for debug only
		void Print();

	private:
		std::map<string, string> userlist;
};

//Create RSA structure using either public key or private key
RSA * createRSA(unsigned char * key, int isPublic);

//Decrypt data using RSA public key
int public_decrypt(unsigned char * enc_data,int data_len,unsigned char * key, unsigned char *decrypted);

//Handle errors during aes-256-gcm encryption
void handleErrors(void);

//Decrypt the plaintext using aes-256-gcm algorithm
//Caller should provide the key, iv and tag
int __decrypt(unsigned char *ciphertext, int ciphertext_len,
		unsigned char *key, unsigned char *iv, unsigned char *tag,
		unsigned char *plaintext);

//Create a random 256-bit key and iv, then call __encrypt to encrypt the text.
//Encrypt the key, iv plus the tag generated by aes-256-gcm using RSA private key.
//*encrypted is the ciphertext with format: RSA_encrypt(KEY+IV+TAG)+AES-256-GCM(plaintext)
void decrypt(string plaintext, unsigned char *encrypted, int *len);

//===============================================================================
//  Implementation
//===============================================================================
int padding = RSA_PKCS1_PADDING;

RSA * createRSA(unsigned char * key,int isPublic)
{
	RSA *rsa= NULL;
	BIO *keybio ;
	keybio = BIO_new_mem_buf(key, -1);
	if (keybio==NULL) {
		printf( "Failed to create key BIO");
		return 0;
	}
	if(isPublic) {
		rsa = PEM_read_bio_RSA_PUBKEY(keybio, &rsa,NULL, NULL);
	} else {
		rsa = PEM_read_bio_RSAPrivateKey(keybio, &rsa,NULL, NULL);
	}
	if(rsa == NULL)	{
		printf( "Failed to create RSA");
	}

	return rsa;
}

int public_decrypt(unsigned char * enc_data,int data_len,unsigned char * key, unsigned char *decrypted)
{
	RSA * rsa = createRSA(key,1);
	int result = RSA_public_decrypt(data_len,enc_data,decrypted,rsa,padding);
	return result;
}

void handleErrors(void) {
	ERR_print_errors_fp(stderr);
	abort();
}

int __decrypt(unsigned char *ciphertext, int ciphertext_len,
		unsigned char *key, unsigned char *iv, unsigned char *tag,
		unsigned char *plaintext);

bool AuthenticateUser::VerifyUser(const string username, const string password) {
	// verify the password
	// copy mcf because libscrypt_check will modify the mcf
	char mcf [SCRYPT_MCF_LEN];
	map<string,string>::iterator it;
	it = userlist.find(username);

	if (it == userlist.end()) {
		//no record is find
		//to prevent timing attack, calculate once scrypt and discard the result
		char dummy[] = "$s1$110801$eoxOLUNIWjyCTQMpHpFV9g==$jQnqJ/RijXlqO9kiKxeLrCOCTsiGgkf+xTpEQHMpSx2BNmC6ckxScioF2qhzL0XLwaGzxx4LQ5wK1s/8wJZpzA==";
		libscrypt_check(dummy, password.c_str());
	   	return false;
	}
	memcpy(mcf, it->second.c_str(), SCRYPT_MCF_LEN);	//skip username
	int ret = libscrypt_check(mcf, password.c_str());
	if(ret<0) {
		printf("Error in checking the password!\n");
		exit(EXIT_FAILURE);
	} else if (ret==0) {
		return false;	//incorrect password
	} else {
		return true;	//correct password
	}
}

void fileError() {
	cerr << "File error!" << endl;
	exit(EXIT_FAILURE);
}

unsigned int toInt(char c) {
	if(c >= '0' && c <= '9') return c - '0';
	if(c >= 'A' && c <= 'F') return 10 + c - 'A';
	return 255;
}

void AuthenticateUser::Load(const string filename) {
	//open file
	FILE *f = fopen(filename.c_str(), "r");
	if (!f) {
		cerr << "Error in open the file" << endl;
		exit(EXIT_FAILURE);
	}
	fseek(f, 0, SEEK_END);
	int length = ftell(f);
	fseek(f, 0, SEEK_SET);
	if (length<512*2)	fileError();

	//allocate storage
	char *hexfile;
	unsigned char *hexDecodeOutput;
	unsigned char *plaintext;
	try {
		hexfile = new char[length+1];
		hexDecodeOutput = new unsigned char[length];
		plaintext = new unsigned char[length+1];
	} catch(std::bad_alloc& exc) {
		cerr << "Cannot allocate enough memory." << endl;
		exit(EXIT_FAILURE);
	}

	const size_t RSA_KEY_LEN = 4096;
	unsigned char key_iv_tag[RSA_KEY_LEN/8];

	//read file and convert hex to bin
	fgets(hexfile, length+1, f);
	for(int i=0; i<length; i++) {
		hexDecodeOutput[i] = 16 * toInt(hexfile[i*2]) + toInt(hexfile[i*2+1]);
	}

	//first 512byte is rsa encrypted key_iv_tag
	int ret = length/2-512;	//cipher length

	//decrypt the key, iv and tag using RSA
	int decrypted_length = public_decrypt(hexDecodeOutput, 512, publicKey, key_iv_tag);
	if(decrypted_length == -1) {
		cerr << "RSA decryption failed: ";
		cerr << "File is not generated by create_user!" << endl;
		exit(EXIT_FAILURE);
	}

	//decrypt the ciphertext using AES-256-GCM
	ret = __decrypt(hexDecodeOutput+512, ret, key_iv_tag, key_iv_tag+32, key_iv_tag+32+16, plaintext);
	if(ret==-1) {
		cerr << "Decryption failed: ";
		cerr << "File is not generated by create_user!" << endl;
		exit(EXIT_FAILURE);
	}

	//Insert the records into userlist
	char *p = strtok((char*)plaintext, "\n");
	while (p) {
		if(strlen(p)<=1) break;
		char username[MAX_USERNAME];
		char password[MAX_PASSWORD];
		char* pos = strchr(p, ':');
		strncpy(username, p, pos-p);
		username[pos-p] = '\0';
		strncpy(password, pos+1, MAX_USERNAME);
		password[strlen(p)-(pos-p)] = '\0';

		userlist.insert( pair<string,string>(username, password) );
		p = strtok(NULL, "\n");
	}

	fclose(f);
	delete[] hexfile;
	delete[] plaintext;
	delete[] hexDecodeOutput;
}

void AuthenticateUser::Print() {
	for(auto it = userlist.cbegin(); it != userlist.cend(); it++)
		cout << it->first << ":" << it->second << endl;
}

int __decrypt(unsigned char *ciphertext, int ciphertext_len,
		unsigned char *key, unsigned char *iv, unsigned char *tag, 
		unsigned char *plaintext)
{
	EVP_CIPHER_CTX *ctx;
	int len;
	int plaintext_len;
	int ret;

	/* Create and initialise the context */
	if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();

	/* Initialise the decryption operation. */
	if(!EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL))
		handleErrors();

	/* Set IV length. Not necessary if this is 12 bytes (96 bits) */
	if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, 16, NULL))
		handleErrors();

	/* Initialise key and IV */
	if(!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv)) handleErrors();

	/* Provide the message to be decrypted, and obtain the plaintext output.
	 * EVP_DecryptUpdate can be called multiple times if necessary
	 */
	if(!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len))
		handleErrors();
	plaintext_len = len;

	/* Set expected tag value. Works in OpenSSL 1.0.1d and later */
	if(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag))
		handleErrors();

	/* Finalise the decryption. A positive return value indicates success,
	 * anything else is a failure - the plaintext is not trustworthy.
	 */
	ret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);

	/* Clean up */
	EVP_CIPHER_CTX_cleanup(ctx);

	if(ret > 0)
	{
		/* Success */
		plaintext_len += len;
		return plaintext_len;
	}
	else
	{
		/* Verify failed */
		return -1;
	}
}

int main()
{
	AuthenticateUser cu;
	cu.Load("list.txt");
	cout << "Please enter your username and password (split by space or newline)." << endl;
	cout << "Use EOF to exit (Ctrl+D)." << endl;

	//input loop
	string username, password;
	//prevent buffer overflow attack
	cin.width(MAX_USERNAME);
	while (cin >> username >> password) {
		if (cu.VerifyUser(username, password))
			cout << "Welcome to the system, " << username 
				 << "!" << endl;
		else 
			cout << "Authentication fail." << endl;
	}

	//debug printing:
	//cu.Print();

	return 0;
}
